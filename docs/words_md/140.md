# 操作系统



操作系统（Operating System，缩写：OS）是管理计算机硬件与软件资源的系统软件，同时也是计算机系统的核心与基石。操作系统需要处理如管理与配置内存、决定系统资源供需的优先次序、控制输入与输出装置、操作网络与管理文件系统等基本事务。操作系统也提供一个让使用者与系统互动的操作界面。

操作系统的型态非常多样，不同机器安装的操作系统可从简单到复杂，可从行动电话的嵌入式系统到超级电脑的大型作业系统。许多操作系统制造者对它涵盖范畴的定义也不尽一致，例如有些操作系统整合了图形用户界面，而有些仅使用命令行界面，而将图形用户界面视为一种非必要的应用程式。

操作系统理论在计算机科学中，为历史悠久time=2017-12-13T03:41:10+00:00的分支；time=2017-12-13T03:41:10+00:00。



## 1 历史

综观电脑之历史，作业系统与电脑硬体的发展息息相关。作业系统之本意原为提供简单的工作排序能力，后为辅助更新更复杂的硬体设施而渐渐演化。从最早的批次模式开始，分时机制也随之出现，在多处理器时代来临时，作业系统也随之添加多处理器协调功能，甚至是分散式系统的协调功能。其他方面的演变也类似于此。另一方面，在个人电脑上，个人电脑之作业系统因袭大型电脑的成长之路，在硬体越来越复杂、强大时，也逐步实践以往衹有大型电脑才有的功能。

总而言之，作业系统的历史就是一部解决电脑系统需求与问题的历史。



### 1.1 1980年代前

第一部电脑并没有作业系统。这是由于早期电脑的建立方式（如同建造机械算盘）与效能不足以执行如此程式。但在1947年发明了电晶体，以及莫里斯·威尔克斯发明的微程序方法，使得电脑不再是机械装置，而是电子产品。系统管理工具以及简化硬体操作流程的程式很快就出现了，且成为作业系统的起源。到了1960年代早期，商用电脑制造商制造了批次处理系统，此系统可将工作的建置、排程以及执行序列化。此时，厂商为每一台不同型号的电脑创造不同的作业系统，因此为某电脑而写的程式无法移植到其他电脑上执行，即使是同型号的电脑也不行。

到了1964年，IBM System/360推出了一系列用途与价位都不同的大型电脑，而它们都共用代号为OS/360的作业系统（而非每种产品都用量身订做的作业系统）。让单一作业系统适用于整个系列的产品是System/360成功的关键，且实际上IBM目前的大型系统便是此系统的后裔，为System/360所写的应用程式依然可以在现代的IBM机器上执行。

OS/360也包含另一个优点：永久贮存装置—硬盘的面世（IBM称为DASD）。另一个关键是分时概念的建立：将大型电脑珍贵的时间资源适当分配到所有使用者身上。分时也让使用者有独占整部机器的感觉；而Multics的分时系统是此时众多新作业系统中实践此观念最成功的。

1963年，奇异公司与贝尔实验室合作以PL/I语言建立的Multics，是激发1970年代众多作业系统建立的灵感来源，尤其是由AT&T贝尔实验室的丹尼斯·里奇与肯·汤普逊所建立的Unix系统，为了实践平台移植能力，此作业系统在1973年由C语言重写；另一个广为市场采用的小型电脑作业系统是VMS。



### 1.2 1980年代

第一代微型计算机并不像大型电脑或小型电脑，没有装设作业系统的需求或能力；它们只需要最基本的作业系统，通常这种作业系统都是从ROM读取的，此种程式被称为监视程式（Monitor）。1980年代，家用电脑开始普及。通常此时的电脑拥有8-bit处理器加上64KB记忆体、萤幕、键盘以及低音质喇叭。而80年代早期最著名的套装电脑为使用微处理器6510（6502晶片特别版）的Commodore C64。此电脑没有作业系统，而是以一8KB唯读记忆体BIOS初始化彩色萤幕、键盘以及软碟机和印表机。它可用8KB唯读记忆体BASIC语言来直接操作BIOS，并依此撰写程式，大部分是游戏。此BASIC语言的直译器勉强可算是此电脑的作业系统，当然就没有核心或软硬体保护机制了。此电脑上的游戏大多跳过BIOS层次，直接控制硬体。

早期最著名的磁碟启动型作业系统是CP/M，它支援许多早期的微电脑。最早期的IBM PC其架构类似C64。当然它们也使用了BIOS以初始化与抽象化硬体的操作，甚至也附了一个BASIC直译器！但是它的BASIC优于其他公司产品的原因在于他有可携性，并且相容于任何符合IBM PC架构的机器上。这样的PC可利用Intel-8088处理器（16-bit暂存器）定址，并最多可有1MB的记忆体，然而最初只有640KB。软式磁碟机取代了过去的磁带机，成为新一代的储存装置，并可在他512KB的空间上读写。为了支援更进一步的档案读写概念，磁碟作业系统（Disk Operating System，DOS）因而诞生。此作业系统可以合并任意数量的磁区，因此可以在一张磁碟片上放置任意数量与大小的档案。档案之间以档名区别。IBM并没有很在意其上的DOS，因此以向外部公司购买的方式取得作业系统。1980年微软公司取得了与IBM的合约，并且收购了一家公司出产的作业系统，在将之修改后以MS-DOS的名义出品，此作业系统可以直接让程式操作BIOS与档案系统。到了Intel-80286处理器的时代，才开始实作基本的储存装置保护措施。其后，MS-DOS成为了IBM PC上面最常用的作业系统（IBM自己也有推出DOS，称为IBM-DOS或PC-DOS）。MS-DOS的成功使得微软成为地球上最赚钱的公司之一。

而1980年代另一个崛起的作业系统异数是Mac OS，此作业系统紧紧与麦金塔电脑捆绑在一起。此时一位施乐帕罗奥多研究中心的员工Dominik Hagen拜访(Visits)了苹果电脑的史蒂夫·乔布斯，并且向他展示了此时全录发展的图形化使用者介面。苹果电脑惊为天人，并打算向全录购买此技术，但因帕罗奥多研究中心并非商业单位而是研究单位，因此全录回绝了这项买卖。在此之后苹果一致认为个人电脑的未来必定属于图形使用者介面，因此也开始发展自己的图形化作业系统。



### 1.3 1990年代

延续1980年代的竞争，1990年代出现了许多影响未来个人电脑市场深厚的作业系统。由于图形化使用者介面日趋繁复，作业系统的能力也越来越复杂与巨大，因此强韧且具有弹性的作业系统就成了迫切的需求。此年代是许多套装类的个人电脑作业系统互相竞争的时代。

上一年代于市场崛起的苹果电脑，由于旧系统的设计不良，使得其后继发展不力，苹果电脑决定重新设计作业系统。经过许多失败的专案后，苹果于1997年释出新作业系统——Mac OS X的测试版，而后推出的正式版取得了巨大的成功。让原先失意离开苹果的史蒂夫·乔布斯风光再现。

除了商业主流的作业系统外，从1980年代起在开放源代码的世界中，BSD系统也发展了非常久的一段时间，但在1990年代由于与AT&T的法律争端，使得远在芬兰赫尔辛基大学的另一股开源作业系统——Linux兴起。Linux核心是一个标准POSIX核心，其血缘可算是Unix家族的一支。Linux与BSD家族都搭配GNU计划所发展的应用程式，但是由于使用的许可证以及历史因素的作弄下，Linux取得了相当可观的开源作业系统市占率，而BSD则小得多。相较于MS-DOS的架构，Linux除了拥有傲人的可移植性（相较于Linux，MS-DOS衹能运行在Intel CPU上），它也是一个分时多行程核心，以及良好的记忆体空间管理（普通的行程不能存取核心区域的记忆体）。想要存取任何非自己的记忆体空间的行程衹能透过系统调用来达成。一般行程是处于使用者模式（User mode）底下，而执行系统呼叫时会被切换成核心模式（Kernel mode），所有的特殊指令衹能在核心模式执行，此措施让核心可以完美管理系统内部与外部装置，并且拒绝无权限的行程提出的请求。因此理论上任何应用程式执行时的错误，都不可能让系统崩溃。

另一方面，微软对于更强力的作业系统呼声的回应便是Windows NT于1993年的面世。

1983年开始微软就想要为MS-DOS建构一个图形化的作业系统应用程式，称为Windows（有人说这是比尔·盖茨被苹果的Lisa电脑上市所刺激）。一开始Windows并不是一个作业系统，只是一个应用程式，其背景还是纯MS-DOS系统，这是因为当时的BIOS设计以及MS-DOS的架构不甚良好之故。在1990年代初，微软与IBM的合作破裂，微软从OS/2（早期为命令列模式，后来成为一个技术很优秀但是曲高和寡的图形化作业系统）专案中抽身，并且在1993年7月27日推出Windows 3.1，一个以OS/2为基础的图形化作业系统。并在1995年8月15日推出Windows 95。这时的Windows系统依然是建立在MS-DOS的基础上，不过微软在这同时也在开发不依赖于DOS的NT系列Windows系统，并在后来完全放弃了DOS而转向NT作为Windows的基础。

底下的表格为Windows NT系统的架构：在硬体阶层之上，有一个由微核心直接接触的硬体抽象层（HAL），而不同的驱动程式以模组的形式挂载在核心上执行。因此微核心可以使用诸如输入输出、档案系统、网路、资讯安全机制与虚拟记忆体等功能。而系统服务层提供所有统一规格的函式呼叫库，可以统一所有子系统的实作方法。例如尽管POSIX与OS/2对于同一件服务的名称与呼叫方法差异甚大，它们一样可以无碍地实作于系统服务层上。在系统服务层之上的子系统，全都是使用者模式，因此可以避免使用者程式执行非法行动。

子系统架构第一个实作的子系统群当然是以前的微软系统。DOS子系统将每个DOS程式当成一行程执行，并以个别独立的MS-DOS虚拟机器承载其运行环境。另外一个是Windows 3.1模拟系统，实际上是在Win32子系统下执行Win16程式。因此达到了安全掌控为MS-DOS与早期Windows系统所撰写之旧版程式的能力。然而此架构只在Intel 80386处理器及后继机型上实作。且某些会直接读取硬体的程式，例如大部分的Win16游戏，就无法套用这套系统，因此很多早期游戏便无法在Windows NT上执行。Windows NT有3.1、3.5、3.51与4.0版。Windows 2000是Windows NT的改进系列（事实上是Windows NT 5.0）、Windows XP（Windows NT 5.1）以及Windows Server 2003（Windows NT 5.2）与Windows Vista（Windows NT 6.0）也都是立基于Windows NT的架构上。

而本年代渐渐增长并越趋复杂的嵌入式设备市场也促使嵌入式作业系统的成长。



### 1.4 今日

现代作业系统通常都有一个使用的绘图装置的图形用户界面（GUI），并附加如滑鼠或触控面版等有别于键盘的输入装置。旧的OS或效能导向的伺服器通常不会有如此亲切的介面，而是以命令行界面（CLI）加上键盘为输入装置。以上两种介面其实都是所谓的壳，其功能为接受并处理使用者的指令（例如按下一按钮，或在命令提示列上键入指令）。

选择要安装的作业系统通常与其硬体架构有很大关系，只有Linux与BSD几乎可在所有硬体架构上执行，而Windows NT仅移植到了DEC Alpha与MIPS Magnum。在1990年代早期，个人电脑的选择就已被局限在Windows家族、类Unix家族以及Linux上，而以Linux及Mac OS X为最主要的另类选择，直至今日。

大型机与嵌入式系统使用很多样化的作业系统。大型主机近期有许多开始支援Java及Linux以便共享其他平台的资源。嵌入式系统近期百家争鸣，从给Sensor Networks用的Berkeley Tiny OS到可以操作Microsoft Office的Windows CE都有。



#### 1.4.1 个人电脑

个人电脑市场目前分为两大阵营，此两种架构分别有支持的作业系统：

* Apple Macintosh - Mac OS X，Windows（仅Intel平台），Linux、BSD。
* IBM相容PC - Windows、Linux、BSD、Mac OS X（非正式支援）。



#### 1.4.2 大型电脑

最早的操作系统是针对20世纪60年代的大型主结构开发的，由于对这些系统在软件方面做了巨大投资，因此原来的计算机厂商继续开发与原来操作系统相兼容的硬件与操作系统。这些早期的操作系统是现代操作系统的先驱。现在仍被支持的大型主机操作系统包括：

* Burroughs MCP-- B5000，1961 to Unisys Clearpath/MCP, present.
* IBM OS/360 -- IBM System/360, 1964 to IBM zSeries, present
* UNIVAC EXEC 8 -- UNIVAC 1108, 1964, to Unisys Clearpath Dorado, present.

现代的大型主机一般也可运行Linux或Unix变种。



#### 1.4.3 嵌入式

嵌入式系统使用非常广泛的系统（如VxWorks、eCos、Symbian OS及Palm OS）以及某些功能缩减版本的Linux或者其他作业系统。某些情况下，OS指称的是一个内建了固定应用软体的巨大泛用程式。在许多最简单的嵌入式系统中，所谓的OS就是指其上唯一的应用程式。



#### 1.4.4 类Unix系统

File:Unix history-simple.png|256px|thumb|Unix系统的演变

default 

所谓的类Unix家族指的是一族种类繁多的OS，此族包含了System V、BSD与Linux。由于Unix是The Open Group的注册商标，特指遵守此公司定义的行为的作业系统。而类Unix通常指的是比原先的Unix包含更多特征的OS。

类Unix系统可在非常多的处理器架构下执行，在伺服器系统上有很高的使用率，例如大专院校或工程应用的工作站。

1991年，芬兰学生林纳斯·托瓦兹根据类Unix系统Minix编写并发布了Linux操作系统内核，其后在理查德·斯托曼的建议下以GNU通用公共许可证发布，成为自由软体Unix变种. Linux近来越来越受欢迎，它们也在个人桌面电脑市场上大有斩获，例如Ubuntu系统。

某些Unix变种，例如惠普的HP-UX以及IBM的AIX仅设计用于自家的硬体产品上，而SUN的Solaris可安装于自家的硬体或x86电脑上。苹果电脑的Mac OS X是一个从NeXTSTEP、Mach以及FreeBSD共同衍生出来的微核心BSD系统，此OS取代了苹果电脑早期非Unix家族的Mac OS。

经历数年的披荆斩棘，自由开源的Linux系统逐渐蚕食以往专利软体的专业领域，例如以往电脑动画运算巨擘──硅谷图形公司（SGI）的IRIX系统已被Linux家族及贝尔实验室研发小组设计的九号计划与Inferno系统取代，皆用于分散运算式环境。它们并不像其他Unix系统，而是选择内建图形用户界面。九号计划原先并不普及，因为它刚推出时并非自由软体。后来改在自由及开源软体许可证Lucent Public License释出后，便开始拥有广大的使用者及社群。Inferno已被售予Vita Nuova并以GPL/MIT许可证释出。

当前，计算机按照计算能力排名世界500强中472台使用Linux，6台使用Windows，其余为各类BSD等Unix。



#### 1.4.5 微软Windows

Microsoft Windows系列作业系统是在微软给IBM机器设计的MS-DOS的基础上设计的图形作业系统。现在的Windows系统，如Windows 2000、Windows XP皆是建立于现代的Windows NT核心。NT核心是由OS/2和OpenVMS等系统上借用来的。Windows可以在32位元和64位元的Intel和AMD的处理器上运行，但是早期的版本也可以在DEC Alpha、MIPS与PowerPC架构上运行。

虽然由于人们对于开放原始码作业系统兴趣的提升，Windows的市场占有率有所下降，但是到2004年为止，Windows作业系统在世界范围内占据了桌面作业系统90%的市场。

Windows系统也被用在低阶和中阶伺服器上，并且支援网页服务的资料库服务等一些功能。最近微软花费了很大研究与开发的经费用于使Windows拥有能运行企业的大型程式的能力。

Windows XP在2001年10月25日发布，2004年8月24日发布服务包2（Service Pack 2），2008年4月21日发布最新的服务包3（Service Pack 3）。

微软上一款作业系统Windows Vista（开发代码为Longhorn）于2007年1月30日发售。Windows Vista增加了许多功能，尤其是系统的安全性和网路管理功能，并且其拥有介面华丽的Aero Glass。但是整体而言，其在全球市场上的口碑却并不是很好。其后继者Windows 7则是于2009年10月22日发售，Windows 7改善了Windows Vista为人诟病的效能问题，相较于Windows Vista，在同样的硬体环境下，Windows 7的表现较Windows Vista为好。而最新的Windows 10则是于2015年7月29日发售。



#### 1.4.6 苹果macOS

macOS，前称“Mac OS X”或“OS X”，是一套运行于苹果Macintosh系列电脑上的操作系统。Mac OS是首个在商用领域成功的图形用户界面系统。Macintosh开发成员包括比尔·阿特金森（Bill Atkinson）、杰夫·拉斯金（Jef Raskin）和安迪·赫茨菲尔德（Andy Hertzfeld）。从OS X 10.8开始在名字中去掉Mac，仅保留OSX和版本号。2016年6月13日在WWDC2016上，苹果公司将OS X更名为macOS，现行的最新的系统版本是macOS Catalina。



#### 1.4.7 Chrome OS

Google Chrome OS是一项Google的轻型电脑操作系统计划，其基于Google的浏览器Google Chrome的Linux内核。



#### 1.4.8 其他

大型主机以及嵌入式作业系统均与Unix或Windows家族关系不大，除了Android，Windows CE、Windows NT及Windows XP Embedded是Windows的血亲产品，以及数种*BSD和嵌入式Linux套件为例外。

少数较旧的OS今日依然在一些需要稳定性的市场中活跃，例如IBM的OS/2、BeOS以及XTS-400。

在达康时代狂潮过后，如AmigaOS与RISC OS等少数人使用的OS依然持续建立，以满足狂热的爱好者社群与特殊专业使用者。

优秀的操作系统必定要具备能让各种能力级别的用户满足各种需求的工具包可视化的高效简便程序环境，以程序来创建程序，就如立法的法律指导规范新的法案的创建。这其实是操作系统所隐含的一部分，决定了可以有多强的扩充能力。比如，某个操作系统有对应的开发者工具包集成环境程序并且是个可视化的，还能让能力不太高的人一看能懂的，用于修改某个声音合成器包含频谱显示，可要是操作系统本身不支持也没有提供可用的工具程序，就会变得很繁琐，很可能为了达到这个目标，开发者就要预备好各种相关的工具程序，甚至自己来编写一系列相关的工具程序创建专门的工具包，最后还要检查代码。若是有人想通过音乐来生成五线谱，要对类似标记语言的五线谱规则对应一下，对各种音色，音准采集并总结出一整套规律，通过声音识别可以识别出乐器的类别等，进而标出乐符完成从声音到乐谱的转换并生成。可是对人声却又更为复杂也不必要如此。若是需要用声音的波形图重现声音，没有相关的工具集是相当难实现，另外只有使用同一套声音的波形绘制规则的所生成的波形图用来再现的声音才是原来的声音。

在作为商品出售的操作系统软件的历史中常常因为其中包含的浏览器，媒体播放器在美国遭到反垄断起诉，差点使得功能上残缺不全。少数操作系统软件能够提供较为全面的App和实用工具程序。

操作系统软件的编译也需要对应的编译环境。

在同一台计算机上运行不同的操作系统软件，就能够以不同的方式来使用计算机资源。比如，在Mac上运行OS X和Windows以两种不同的技术OpenCL，Core Image:DirectX来使用图形卡实现类似的作用。

通过图像识别和声音识别来进行信息搜索。

能够满足不同需求所要求的精确程度对时间的精细划分，以及尺度细分可以互联，同步，协调原本必须由多个人协同合作才能完成的随时需要调整并相互同步的操控作业，这就必须有即时消息传送显示，可视化的用于协调同步计划任务的配置脚本，以及执行这样计划任务的完整组件。



### 1.5 未来

研究与建立未来的作业系统依旧进行著。作业系统朝提供更省电、网路化、易用、华丽的使用者介面的方向来改进。类UNIX OS通过和桌面环境开发者协作，正努力让自己改进使用环境。

eyeOS是一套基于PHP实现的半开源模拟云端运算操作系统，但其实质只是在网路浏览器中提供一种类似无界限的类独立操作系统，其并非于任何类似虚拟化中实现的真正电脑操作系统，能提供诸如Word、PPT、Excel的在线处理功能…

GNU Hurd是一个以完全相容Unix并加强许多功能为目标的微核心架构。微软Singularity是一个奠基于.Net并以建立较佳记忆体保护机制为目标的研究计划。



## 2 功能

操作系统位于底层硬件与用户之间，是两者沟通的桥梁。用户可以通过操作系统的用户界面，输入命令。操作系统则对命令进行解释，驱动硬件设备，实现用户要求。以现代标准而言，一个标准PC的操作系统应该提供以下的功能：

* 进程管理（Processing management）
* 内存管理（Memory management）
* 文件系统（File system）
* 网络通信（Networking）
* 安全机制（Security）
* 用户界面（User interface）
* 驱动程序（Device drivers）



### 2.1 进程管理

不管是常驻程式或者应用程式，他们都以行程为标准执行单位。当年运用冯·诺伊曼结构建造电脑时，每个中央处理器最多只能同时执行一个行程。早期的操作系统（例如DOS）也不允许任何程式打破这个限制，且DOS同时只有执行一个进程（虽然DOS自己宣称他们拥有终止并等待驻留能力，可以部分且艰难地解决这问题）。现代的作业系统，即使只拥有一个CPU，也可以利用多进程（multitask）功能同时执行多个进程。进程管理指的是操作系统调整多个行程的功能。

由于大部分的电脑只包含一颗中央处理器，在单核心（Core）的情况下多行程只是简单迅速地切换各行程，让每个行程都能够执行，在多核心或多处理器的情况下，所有行程透过许多协同技术在各处理器或核心上转换。越多行程同时执行，每个行程能分配到的时间比率就越小。很多操作系统在遇到此问题时会出现诸如音效断续或滑鼠跳格的情况（称做颠簸（Thrashing），一种操作系统只能不停执行自己的管理程式并耗尽系统资源的状态，其他使用者或硬体的程式皆无法执行。行程管理通常实践了分时的概念，大部分的操作系统可以利用指定不同的特权等级（priority），为每个行程改变所占的分时比例。特权越高的行程，执行优先顺序越高，单位时间内占的比例也越高。互动式操作系统也提供某种程度的回馈机制，让直接与使用者互动的行程拥有较高的特权值。

除了行程管理之外，操作系统尚有担负起行程间通讯（IPC）、行程异常终止处理以及死锁（Dead Lock）侦测及处理等较为艰深的问题。

在行程之下尚有执行绪的问题，但是大部分的操作系统并不会处理执行绪所遭遇的问题，通常操作系统仅止于提供一组API让使用者自行操作或透过虚拟机器的管理机制控制执行绪之间的互动。



### 2.2 内存管理

根据帕金森定律：「你给程序再多内存，程序也会想尽办法耗光」，因此程式设计师通常希望系统给他无限量且无限快的记忆体。大部分的现代电脑记忆体架构都是阶层式的，最快且数量最少的暂存器为首，然后是快取、记忆体以及最慢的磁碟储存装置。而操作系统的记忆体管理提供寻找可用的记忆空间、配置与释放记忆空间以及交换记忆体和低速储存装置的内含物……等功能。此类又被称做虚拟记忆体管理的功能大幅增加每个行程可获得的记忆空间（通常是4GB，即使实际上RAM的数量远少于这数目）。然而这也带来了微幅降低执行效率的缺点，严重时甚至也会导致行程崩溃。

记忆体管理的另一个重点活动就是借由CPU的帮助来管理虚拟位置。如果同时有许多行程储存于记忆装置上，作业系统必须防止它们互相干扰对方的记忆体内容（除非透过某些协定在可控制的范围下操作，并限制可存取的记忆体范围）。分割记忆体空间可以达成目标。每个行程只会看到整个记忆体空间（从0到记忆体空间的最大上限）被配置给它自己（当然，有些位置被操作系统保留而禁止存取）。CPU事先存了几个表以比对虚拟位置与实际记忆体位置，这种方法称为分页配置。

借由对每个行程产生分开独立的位置空间，操作系统也可以轻易地一次释放某行程所占据的所有记忆体。如果这个行程不释放记忆体，操作系统可以结束行程并将记忆体自动释放。



### 2.3 磁盘与文件系统

所谓的档案系统，通常指称管理磁碟资料的系统，可将资料以目录或档案的型式储存。每个档案系统都有自己的特殊格式与功能，例如日志管理或不需磁碟重整。

操作系统拥有许多种内建档案系统。例如Linux拥有非常广泛的内建档案系统，如ext2、ext3、ext4、ReiserFS、Reiser4、GFS、GFS2、OCFS、OCFS2、NILFS与Google档案系统。Linux也支援非原生档案系统，例如XFS、JFS、FAT家族与NTFS。另一方面，Windows能支援的档案系统衹有FAT12、FAT16、FAT32、EXFAT与NTFS。NTFS系统是Windows上最可靠与最有效率的档案系统。其他的FAT家族都比NTFS老旧，且对于档案长度与分割磁碟能力都有很大限制，因此造成很多问题。而UNIX的档案系统多半是UFS，而UNIX中的一个分支Solaris最近则开始支援一种新式的ZFS。

大部份上述的档案系统都有两种建置方法。系统可以以日志式或非日志式建置。日志式档案系统可以以较安全的手法执行系统恢复。如果一个没有日志式建置的档案系统遇上突然的系统崩溃，导致资料建立在一半时停顿，则此系统需要特殊的档案系统检查工具才能复原；日志式则可自动恢复。微软的NTFS与Linux的ext3、ext4、reiserFS与JFS都是日志式档案系统。

每个档案系统都实作相似的目录／子目录架构，但在相似之下也有许多不同点。微软使用「\」符号以建立目录／子目录关系，且档案名称忽略其大小写差异；UNIX系统则是以「/」建立目录架构，且档案名称大小写有差异。(其实这是给系统调用的，"/"或"\"并不实际存在硬碟)



### 2.4 网络

许多现代的操作系统都具备操作主流网路通讯协定TCP/IP的能力。也就是说这样的作业系统可以进入网路世界，并且与其他系统分享诸如档案、印表机与扫描器等资源。

许多操作系统也支援多个过去网路启蒙时代的各路网路通讯协定，例如IBM建立的系统网路架构、DEC在它所生产的系统所设定的DECnet架构与微软为Windows制作的特殊通讯协定。还有许多为了特殊功能而研发的通讯协定，例如可以在网路上提供档案存取功能的NFS系统。现今大量用于影音串流（Streaming media）及游戏讯息传送的UDP协定等。



### 2.5 安全

大多数操作系统都含有某种程度的资讯安全机制。资讯安全机制主要基于两大理念：

* 操作系统提供外界直接或间接存取数种资源的管道，例如本地端磁碟机的档案、受保护的特权系统呼叫、使用者的隐私资料与系统执行的程式所提供的服务。
* 操作系统有能力认证资源存取的请求。允许通过认证的请求并拒绝无法通过的非法请求，并将适当的权力授权（授权）给此请求。有些系统的认证机制仅简略地把资源分为特权或非特权，且每个请求都有独特的身份辨识号码，例如使用者名称。资源请求通常分成两大种类：
 * 内部来源：通常是一个正在执行的程式发出的资源请求。在某些系统上，一个程式一旦可执行就可做任何事情（例如DOS时代的病毒），但通常操作系统会给程式一个识别代号，并且在此程式发出请求时，检查其代号与所需资源的存取权限关系。
 * 外部来源：从非本地端电脑而来的资源请求，例如远端登入本机电脑或某些网路连线请求（FTP或HTTP）。为了识别这些外部请求，系统也许会对此请求提出认证要求。通常是请求输入使用者名称以及相对应的密码。系统有时也会应用诸如磁卡或生物识别资料的它种认证方法。在某些例子，例如网路通讯上，通常不需通过认证即可存取资源（例如匿名存取的FTP伺服器或P2P服务）。

除了允许／拒绝形式的安全机制，一个高安全等级的系统也会提供记录选项，允许记录各种请求对资源存取的行为（例如「谁曾经读了这个档案？」）。

肇因于军方与商业组织将敏感资料记录在电脑上，安全机制在操作系统历史上是一个被长久关注与讨论的问题。美国国防部（DoD）便创立了《可信赖之计算机系统评鉴程序》（TCSEC），此手册确立了评鉴安全机制成效的基本原则。这对操作系统作者来说非常重要，因为TCSEC是用于评鉴、分类与选拔出用于处理、储存与获取敏感或机密资料的电脑系统的标准程序。



#### 2.5.1 内部通讯安全

内部资讯安全可视为防止正在执行的程式任意存取系统资源的手段。大多操作系统让普通程式可直接操作电脑的CPU，所以产生了一些问题，例如怎样把可如操作系统一样处理事务、执行同样特殊指令的程式强迫停止，毕竟在此情境下，操作系统也只是另一个平起平坐的程式。为通用操作系统所生产的CPU通常于硬体层级上实践了一定程度的特殊指令保护概念。通常特权层级较低的程式想要执行某些特殊指令时会被阻断，例如直接存取像是硬碟之类的外部装置。因此，程式必须得经由询问操作系统，让操作系统执行特殊指令来存取磁碟。因此操作系统就有机会检查此程式的识别身份，并依此接受或拒绝它的请求。

在不支援特殊指令架构的硬体上，另一个也是唯一的保护方法，则是操作系统并不直接利用CPU执行使用者的程式，而是借由模拟一个CPU或提供一P-code机系统（伪代码执行机），像是Java一样让程式在虚拟机器上执行。

内部安全机制在多使用者电脑上特别重要：它允许每个系统使用者拥有自己个人的档案与目录，且其他使用者不能任意存取或删除。因为任何程式都可能绕过操作系统的监控，更有可能绕过侧录程式的监控，拥有强制力的内部安全机制在侧录启动时也非常重要。



#### 2.5.2 外部通讯安全

通常一个作业系统会为其他网路上的电脑或使用者提供（主持）各种服务。这些服务通常借由端口或操作系统网路地址后的数字存取点提供。通常此服务包括提供档案共享（NFS）、列印共享、电子邮件、网页服务与档案传输协定（FTP）。

外部资讯安全的最前线，是诸如防火墙等的硬体装置。在操作系统内部也常设置许多种类的软体防火墙。软体防火墙可设定接受或拒绝在操作系统上执行的服务与外界的连线。因此任何人都可以安装并执行某些不安全的网路服务，例如Telnet或FTP，并且设定除了某些自用通道之外阻挡其他所有连线，以达成防堵不良连线的机制。



### 2.6 用户界面

今日大部分的操作系统都包含图形用户界面（GUI）。有几类较旧的操作系统将图形化使用者介面与核心紧密结合，例如最早的Windows与Mac OS实作产品。此种手法可提供较快速的图形回应能力，且实作时不需切割模组因而较为省工，但是会有强烈副作用，例如图形系统崩溃将导致整个系统崩溃，例如蓝屏死机。许多近代的操作系统已模组化，将图形介面的子系统与核心分开（已知Linux与Mac OS X原先就是如此设计，而某些扩充版本的Windows终于也采用此手法）。

许多操作系统允许使用者安装或创造任何他们喜欢的图形用户界面。大部分的Unix与Unix衍生系统（BSD、Linux与Minix）通常会安装X Window系统配合GNOME或KDE桌面环境。而某些操作系统就没有这么弹性的图形化使用者介面，例如Windows。这类的操作系统只能透过外加的程式来改变其图形化使用者介面，甚至根本只能改变诸如选单风格或颜色配置等部分time=2007-07-16T11:03:06Z。

图形化使用者介面与时并进，例如Windows在每次新版本上市时就会将其图形化使用者介面改头换面，而Mac OS的GUI也在Mac OS X上市时出现重大转变。



### 2.7 驱动程序

所谓的驱动程式（Device driver）是指某类设计来与硬体互动的电脑软体。通常是一设计完善的装置互动介面，利用与此硬体连接的电脑汇排流或通讯子系统，提供对此装置下令与接收资讯的功能；以及最终目的，将讯息提供给操作系统或应用程式。驱动程式是针对特定硬体与特定操作系统设计的软体，通常以作业系统核心模组、应用软体包或普通电脑程式的形式在操作系统核心底下执行，以达到通透顺畅地与硬体互动的效果，且提供硬体在处理非同步的时间依赖性介面（asynchronous time-dependent hardware interface）时所需的中断处理常式。

设计驱动程式的主要目的在于操作抽象化，任何硬体模组，既使是同一类的装置，在硬体设计面上也有巨大差异。厂商推出的较新模组通常更可靠更有效率，控制方法也会有所不同。电脑与其操作系统每每不能预期那些现有与新装置的变异之处，因此无法知道其操作方法。为解决此问题操作系统通常会主动制订每种装置该有的操作方式，而驱动程式功能则是将那些操作系统制订的行为描述，转译为可让装置了解的自订操作手法。

理论上适合的驱动程式一旦安装，相对应的新装置就可以无误地执行。此新驱动程式可以让此装置完美地切合在操作系统中，让使用者察觉不到这是操作系统原本没有的功能。



## 3 结构

操作系统理论研究者有时把操作系统分成四大部分：

* 驱动程序 - 最底层的、直接控制和监视各类硬件的部分，它们的职责是隐藏硬件的具体细节，并向其他部分提供一个抽象的、通用的接口。
* 内核 - 操作系统之最核心部分，通常运行在最高特权级，负责提供基础性、结构性的功能。
* 支承库 - （亦作“接口库”）是一系列特殊的程序库，它们职责在于把系统所提供的基本服务包装成应用程序所能够使用的编程接口（API），是最靠近应用程序的部分。例如，GNU C运行期库就属于此类，它把各种操作系统的内部编程接口包装成ANSI C和POSIX编程接口的形式。
* 外围 - 所谓外围，是指操作系统中除以上三类以外的所有其他部分，通常是用于提供特定高级服务的部件。例如，在微内核结构中，大部分系统服务，以及UNIX/Linux中各种守护进程都通常被划归此列。

当然，本节所提出的四部结构观也绝非放之四海皆准。例如，在早期的微软视窗操作系统中，各部分耦合程度很深，难以区分彼此。而在使用外核结构的操作系统中，则根本没有驱动程序的概念。因而，本节的讨论只适用于一般情况，具体特例需具体分析。

操作系统中四大部分的不同布局，也就形成了几种整体结构的分野。常见的结构包括：简单结构、层结构、微内核结构、垂直结构、和虚拟机结构。



## 4 分类

操作系统的分类没有一个单一的标准，可以根据工作方式分为批处理操作系统、分时操作系统、实时操作系统、网络操作系统和分布式操作系统等；根据架构可以分为单内核操作系统等；根据运行的环境，可以分为桌面操作系统，嵌入式操作系统等；根据指令的长度分为8bit, 16bit, 32bit, 64bit的操作系统。



### 4.1 内核结构

内核是操作系统最核心最基础的构件，其结构往往对操作系统的外部特性以及应用领域有着一定程度的影响。尽管随着理论和实践的不断演进，操作系统高层特性与内核结构之间的耦合有日趋缩小之势，但习惯上，内核结构仍然是操作系统分类之常用标准。

内核的结构可以分为单内核、微内核、超微内核、以及外核等。

单内核结构是操作系统中各核心部件杂然混居的形态，该结构产生于1960年代（亦有1950年代初之说，尚存争议），历史最长，是操作系统内核与外围分离时的最初形态。

微内核结构是1980年代产生出来的较新的内核结构，强调结构性部件与功能性部件的分离。20世纪末，基于微内核结构，理论界中又发展出了超微内核与外内核等多种结构。尽管自1980年代起，大部分理论研究都集中在以微内核为首的“新兴”结构之上，然而，在应用领域之中，以单内核结构为基础的操作系统却一直占据着主导地位。

在众多常用操作系统之中，除了QNX和基于Mach的UNIX等个别系统外，几乎全部采用单内核结构，例如大部分的Unix、Linux，以及Windows（微软声称Windows NT是基于改良的微内核架构的，尽管理论界对此存有异议）。

微内核和超微内核结构主要用于研究性操作系统，还有一些嵌入式系统使用外核。

基于单内核的操作系统通常有着较长的历史渊源。例如，绝大部分UNIX的家族史都可上溯至1960年代。该类操作系统多数有着相对古老的设计和实现（例如某些UNIX中存在着大量1970年代、1980年代的代码）。另外，往往在性能方面略优于同一应用领域中采用其他内核结构的操作系统（但通常认为此种性能优势不能完全归功于单内核结构）。



### 4.2 通用与专用、嵌入式

通用操作系统是面向一般没有特定应用需求的操作系统。由于没有特定的应用需求，通用操作系统为了适应更广泛的应用，需要支持更多的硬件与软件，需要针对所有的用户体验，对系统进行更新。通用操作系统是一个工程量繁重的操作系统。



### 4.3 实时与非实时

「实时操作系统」（Real Time OS）泛指所有据有一定实时资源调度以及通讯能力的操作系统。而所谓“实时”，不同语境中往往有着非常不同的意义。某些时候仅仅用作“高性能”的同义词。但在操作系统理论中“实时性”所指的通常是特定操作所消耗的时间（以及空间）的上限是可预知的。比如，如果说某个操作系统提供实时内存分配操作，那也就是说一个内存分配操作所用时间（及空间）无论如何也不会超出操作系统所承诺的上限。实时性在某些领域非常重要，比如在工业控制、医疗器材、影音频合成、以及军事领域，实时性都是无可或缺的特性。

常用实时操作系统有QNX、VxWorks、RTLinux等等，而Linux、多数UNIX、以及多数Windows家族成员等都属于非实时操作系统。操作系统整体的实时性通常依仗内核的实时能力，但有时也可在非实时内核上建立实时操作系统，很多在Windows上建立的实时操作系统就属于此类。

在POSIX标准中专有一系用于规范实时操作系统的API，其中包括POSIX.4、POSIX.4a、POSIX.4b（合称POSIX.4）以及POSIX.13等等。符合POSIX.4的操作系统通常被认可为实时操作系统（但实时操作系统并不需要符合POSIX.4标准）。



### 4.4 8位、16位、32位、64位、128位

所谓8位、16位、32位、64位、128位等术语有时指汇流排宽度，有时指指令宽度（在定长指令集中），而在作业系统理论中主要是指记忆体定址的宽度。如果记忆体的定址宽度是16位，那么每一个记忆体地址可以用16个二进位位来表示，也就是说可以在64KB的范围内定址。同样道理32位的宽度对应4GB的定址范围，64位的宽度对应16 Exabyte的定址范围。记忆体定址范围并非仅仅是对作业系统而言的，其他类型的软件的设计有时也会被定址范围而影响。但是在作业系统的设计与实现中，定址范围却有着更为重要的意义。

在早期的16位作业系统中，由于64KB的定址范围太小，大都都采用「段」加「线性地址」的二维平面地址空间的设计。分配记忆体时通常需要考虑「段置换」的问题，同时，应用程序所能够使用的地址空间也往往有比较小的上限。

在32位作业系统中，4GB的定址范围对于一般应用程序来说是绰绰有余的，因而，通常使用一维的线性地址空间，而不使用「段」。



## 5 注释



## 6 参考文献



### 6.1 引用



### 6.2 来源

* （俗称恐龙书，OS教科书圣经本）
* （Linux由此书而启发，可惜新版本将实作内容移除）



## 7 参见

* 计算机
* 操作系统内核
* 实时操作系统-分时系统-多任务-嵌入式系统-单一用户-多用户
* 对称多处理机（SMP）-集群（Cluster）-分布式计算
* 64位操作系统

 部分操作系统

* Unix
* FreeBSD
* Solaris
* AIX
* HP-UX
* IRIX
* Tru64
* MS-DOS
* GNU/Linux
* Mac OS
* Windows
* Windows NT
* 其它操作系统



## 8 外部连结

* OS的历史
* 简略OS介绍的教育网站....
* OSDP，所有作业系统的文件网站
* Unix OS家族的历史树
* Windows的历史
* TLDP，Linux核心彻底讲解，适用于想要彻底了解OS核心结构者
* 作业系统原理介绍



